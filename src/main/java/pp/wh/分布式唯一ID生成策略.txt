1、终极版：分布式唯一ID的几种生成方案
总的来说，大概有三大类方法，分别是：数据库自增ID、UUID生成、snowflake雪花算法。
https://www.jianshu.com/p/4ba1c5e8c185

一、数据库自增ID
核心思想：使用数据库的id自增策略（如: Mysql的auto_increment）。
优点：
① 简单，天然有序。

缺点：
① 并发性不好。
② 数据库写压力大。
③ 数据库故障后不可使用。
④ 存在数量泄露风险。

针对以上缺点，有以下几种优化方案： 
1. 数据库水平拆分，设置不同的初始值和相同的自增步长

   核心思想：将数据库进行水平拆分，每个数据库设置不同的初始值和相同的自增步长。

2. 批量缓存自增ID

    核心思想：如果使用单台机器做ID生成，可以避免固定步长带来的扩容问题（方案1的缺点）。
    具体做法是：每次批量生成一批ID给不同的机器去慢慢消费，这样数据库的压力也会减小到N分之一，且故障后可坚持一段时间。 
    缺点：服务器重启、单点故障会造成ID不连续。

3. Redis生成ID

     核心思想：Redis的所有命令操作都是单线程的，本身提供像 incr 和 increby 这样的自增原子命令，所以能保证生成的 ID 肯定是唯一有序的。

    优点：
    ① 不依赖于数据库，灵活方便，且性能优于数据库。
    ② 数字ID天然排序，对分页或者需要排序的结果很有帮助。

    缺点：
    ① 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。
    ② 需要编码和配置的工作量比较大。

    优化方案：
    考虑到单节点的性能瓶颈，可以使用 Redis 集群来获取更高的吞吐量，并利用上面的方案（①数据库水平拆分，设置不同的初始值和相同的步长； ②批量缓存自增ID）来配置集群。
    PS：比较适合使用 Redis 来生成每天从0开始的流水号。比如：“订单号=日期+当日自增长号”，则可以每天在Redis中生成一个Key，使用INCR进行累加。


三、雪花算法

    核心思想：把64-bit分别划分成多段，分开来标示机器、时间、某一并发序列等，从而使每台机器及同一机器生成的ID都是互不相同。
    PS：这种结构是雪花算法提出者Twitter的分法，但实际上这种算法使用可以很灵活，根据自身业务的并发情况、机器分布、使用年限等，可以自由地重新决定各部分的位数，从而增加或减少某部分的量级。比如：百度的UidGenerator、美团的Leaf等，都是基于雪花算法做一些适合自身业务的变化
    优点：
    ①整体上按照时间按时间趋势递增，后续插入索引树的时候性能较好。
    ②整个分布式系统内不会产生ID碰撞（由数据中心标识ID、机器标识ID作区分）。
    ③本地生成，且不依赖数据库（或第三方组件），没有网络消耗，所以效率高（每秒能够产生26万ID左右）。

    缺点：
    ①由于雪花算法是强依赖于时间的，在分布式环境下，如果发生时钟回拨，很可能会引起ID重复、ID乱序、服务会处于不可用状态等问题。

    解决方案有：
    a. 将ID生成交给少量服务器，并关闭时钟同步。
    b. 直接报错，交给上层业务处理。
    c. 如果回拨时间较短，在耗时要求内，比如5ms，那么等待回拨时长后再进行生成。
    d. 如果回拨时间很长，那么无法等待，可以匀出少量位（1~2位）作为回拨位，一旦时钟回拨，将回拨位加1，可得到不一样的ID，2位回拨位允许标记3次时钟回拨，基本够使用。如果超出了，可以再选择抛出异常。

   4. 美团Leaf算法